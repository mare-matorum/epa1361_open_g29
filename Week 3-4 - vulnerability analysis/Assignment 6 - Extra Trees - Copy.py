#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed May 12 15:33:26 2021

@author: wenyuc
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import statsmodels.api as sm
from patsy.highlevel import dmatrices

from ema_workbench import (Model, RealParameter, TimeSeriesOutcome, ScalarOutcome, perform_experiments, ema_logging, SequentialEvaluator)
from ema_workbench.analysis import plotting, plotting_util
from ema_workbench.em_framework.evaluators import LHS, SOBOL, MORRIS

from ema_workbench.analysis import feature_scoring
from ema_workbench.analysis.scenario_discovery_util import RuleInductionType
from ema_workbench.em_framework.salib_samplers import get_SALib_problem
from SALib.analyze import sobol

from ema_workbench import ema_logging
ema_logging.log_to_stderr(ema_logging.INFO)

def pred_prey(prey_birth_rate=0.025, predation_rate=0.0015, predator_efficiency=0.002,
             predator_loss_rate=0.06, initial_prey=50, initial_predators=20, dt=0.25, 
             final_time=365, reps=1):

    #Initial values
    predators = np.zeros((reps, int(final_time/dt)+1))
    prey = np.zeros((reps, int(final_time/dt)+1))
    sim_time = np.zeros((reps, int(final_time/dt)+1))
    
    for r in range(reps):

        predators[r,0] = initial_predators
        prey[r,0] = initial_prey

    #Calculate the time series
    for t in range(0, sim_time.shape[1]-1):

        dx = (prey_birth_rate*prey[r,t]) - (predation_rate*prey[r,t]*predators[r,t])
        dy = (predator_efficiency*predators[r,t]*prey[r,t]) - (predator_loss_rate*predators[r,t])

        prey[r,t+1] = max(prey[r,t] + dx*dt, 0)
        predators[r,t+1] = max(predators[r,t] + dy*dt, 0)
        sim_time[r,t+1] = (t+1)*dt
    
    #Return outcomes
    return {'TIME':sim_time,
            'predators':predators,
            'prey':prey}


def calculate_tree(input_data, output_data, column_name, nr_trees_input, nr_max_features_input):
    fs = feature_scoring.get_ex_feature_scores(input_data, output_data, mode=RuleInductionType.REGRESSION, nr_trees=nr_trees_input, max_features=nr_max_features_input)

    output_dataframe = fs[0]
    output_dataframe.columns = [column_name]
    
    # Extract dataframe from output tuple
    return fs[0]

def tree_generate_heatmap(final, mean, std, nr_trees_input, nr_max_features_input, subplot):
    output_prey_final = calculate_tree(x, final, "prey_final", nr_trees_input, nr_max_features_input)
    output_prey_mean = calculate_tree(x, mean, "prey_mean", nr_trees_input, nr_max_features_input)
    output_prey_std = calculate_tree(x, std, "prey_std", nr_trees_input, nr_max_features_input)
    
    # Concatenate dataframes to have all columns in one dataframe
    frames = [output_prey_final, output_prey_mean, output_prey_std]
    frames_together = pd.concat(frames, axis=1)
    
    # Plot heatmap
    sns.heatmap(frames_together, cmap='viridis', annot=True, ax=subplot)


model = Model('PredPreyGSA', function=pred_prey) 

model.uncertainties = [RealParameter('prey_birth_rate', 0.015, 0.035),
                     RealParameter('predation_rate', 0.0005, 0.003),
                     RealParameter('predator_efficiency', 0.001, 0.004),
                     RealParameter('predator_loss_rate', 0.04, 0.08)] 

model.outcomes = [TimeSeriesOutcome('TIME', function=np.squeeze),
                TimeSeriesOutcome('predators', function=np.squeeze),
                TimeSeriesOutcome('prey', function=np.squeeze)]
    
with SequentialEvaluator(model) as evaluator:
        experiments, outcomes = evaluator.perform_experiments(scenarios=1000, uncertainty_sampling=LHS)

# Store final values of prey outcome
prey_final = []
prey_mean = []
prey_std = []

# Iterate through rows of outcome numpy array (experiments) to calculate indicators
for experiment_row in outcomes["prey"]:
    prey_final.append(experiment_row[-1]) # Get last element
    prey_mean.append(np.mean(experiment_row))
    prey_std.append(np.std(experiment_row))


# Convert outputs to numpy array 
prey_final_np = np.array(prey_final)
prey_mean_np = np.array(prey_mean)   
prey_std_np = np.array(prey_std)

# Store outputs in dictionary
indicators = {'prey_final':prey_final_np, 'prey_mean':prey_mean_np, 'prey_std':prey_std_np}

#Feature scoring 
#is it okay that the outcomes in indicators are list but not numpy array?
x = experiments
#y = np.array(prey_final)
y = pd.DataFrame(indicators)  

fig1 = plt.figure()
fig1.tight_layout()
fig1.suptitle("Number of trees (10, 100, 1000)")
ax1 = fig1.add_subplot(311)
ax2 = fig1.add_subplot(312)
ax3 = fig1.add_subplot(313)

# Generate heatmaps for different parameters of tree number
tree_generate_heatmap(prey_final_np, prey_mean_np, prey_std_np, 10, 0.6, ax1)
tree_generate_heatmap(prey_final_np, prey_mean_np, prey_std_np, 100, 0.6, ax2)
tree_generate_heatmap(prey_final_np, prey_mean_np, prey_std_np, 1000, 0.6, ax3)

# The findings are very robust against the number of trees. 100 trees provide a sufficient approximation.
# Increasing the number by 1-2 order of magnitudes does not change the results significantly.
# The effects of predator efficiency and its interactions with other uncertainties have the highest impact on the mean value of prey.

fig2 = plt.figure()
fig2.tight_layout()
fig2.suptitle("Max. features (0.4, 0.6, 0.8)")
ax1 = fig2.add_subplot(311)
ax2 = fig2.add_subplot(312)
ax3 = fig2.add_subplot(313)

# Generate heatmaps for different parameters of max. features
tree_generate_heatmap(prey_final_np, prey_mean_np, prey_std_np, 100, 0.4, ax1)
tree_generate_heatmap(prey_final_np, prey_mean_np, prey_std_np, 100, 0.6, ax2)
tree_generate_heatmap(prey_final_np, prey_mean_np, prey_std_np, 100, 0.8, ax3)

plt.show()











