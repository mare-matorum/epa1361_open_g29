#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed May 12 15:33:26 2021

@author: wenyuc
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import statsmodels.api as sm
from patsy.highlevel import dmatrices

from ema_workbench import (Model, RealParameter, TimeSeriesOutcome, ScalarOutcome, perform_experiments, ema_logging, SequentialEvaluator)
from ema_workbench.analysis import plotting, plotting_util
from ema_workbench.em_framework.evaluators import LHS, SOBOL, MORRIS

from ema_workbench.analysis import feature_scoring
from ema_workbench.analysis.scenario_discovery_util import RuleInductionType
from ema_workbench.em_framework.salib_samplers import get_SALib_problem
from SALib.analyze import sobol

from ema_workbench import ema_logging
ema_logging.log_to_stderr(ema_logging.INFO)

def pred_prey(prey_birth_rate=0.025, predation_rate=0.0015, predator_efficiency=0.002,
             predator_loss_rate=0.06, initial_prey=50, initial_predators=20, dt=0.25, 
             final_time=365, reps=1):

    #Initial values
    predators = np.zeros((reps, int(final_time/dt)+1))
    prey = np.zeros((reps, int(final_time/dt)+1))
    sim_time = np.zeros((reps, int(final_time/dt)+1))
    
    for r in range(reps):

        predators[r,0] = initial_predators
        prey[r,0] = initial_prey

    #Calculate the time series
    for t in range(0, sim_time.shape[1]-1):

        dx = (prey_birth_rate*prey[r,t]) - (predation_rate*prey[r,t]*predators[r,t])
        dy = (predator_efficiency*predators[r,t]*prey[r,t]) - (predator_loss_rate*predators[r,t])

        prey[r,t+1] = max(prey[r,t] + dx*dt, 0)
        predators[r,t+1] = max(predators[r,t] + dy*dt, 0)
        sim_time[r,t+1] = (t+1)*dt
    
    #Return outcomes
    return {'TIME':sim_time,
            'predators':predators,
            'prey':prey}


model = Model('PredPreyGSA', function=pred_prey) 

model.uncertainties = [RealParameter('prey_birth_rate', 0.015, 0.035),
                     RealParameter('predation_rate', 0.0005, 0.003),
                     RealParameter('predator_efficiency', 0.001, 0.004),
                     RealParameter('predator_loss_rate', 0.04, 0.08)] 

model.outcomes = [TimeSeriesOutcome('TIME', function=np.squeeze),
                TimeSeriesOutcome('predators', function=np.squeeze),
                TimeSeriesOutcome('prey', function=np.squeeze)]
    
with SequentialEvaluator(model) as evaluator:
        experiments, outcomes = evaluator.perform_experiments(scenarios=1000, uncertainty_sampling=LHS)

# Store final values of prey outcome
prey_final = []
prey_mean = []
prey_std = []

# Iterate through rows of outcome numpy array (experiments) to calculate indicators
for experiment_row in outcomes["prey"]:
    prey_final.append(experiment_row[-1]) # Get last element
    prey_mean.append(np.mean(experiment_row))
    prey_std.append(np.std(experiment_row))


indicators = {'prey_final':prey_final, 'prey_mean':prey_mean, 'prey_std':prey_std}


#Feature scoring 
#is it okay that the outcomes in indicators are list but not numpy array?
x = experiments
#y = np.array(prey_final)
y = indicators


#print(y.ndim) #testing dimension of the array, y should be 1D array

#ema_workbench.analysis.feature_scoring.get_ex_feature_scores
#(x, y, mode=<RuleInductionType.CLASSIFICATION: 'classification'>, nr_trees=100, 
#max_features=None, max_depth=None, min_samples_split=2, min_samples_leaf=None, 
#min_weight_fraction_leaf=0, max_leaf_nodes=None, bootstrap=True, oob_score=True, random_state=None)


fs = feature_scoring.get_ex_feature_scores(x, y, mode=RuleInductionType.REGRESSION, nr_trees=100, max_features=0.6)

sns.heatmap(fs, cmap='viridis', annot=True)
plt.show()











